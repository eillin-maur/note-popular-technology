# Краткий экскурс по Kafka

## 1. Что такое и сценарии использования
Apache Kafka - распределенная, масштабируемая, централизованная система обмена сообщениями в режиме реального времени, которая дает возможность публикации потоков данных и подписки на них, их хранения и обработки.

Преимущества:
- горизонтальная масштабируемость путем добавления нод в кластер.
- отказоустойчивость за счет репликации партиций на ведомые ноды.
- безопасность за счет SSL-шифрования, различных вариантов авторизации, гарантий доставки сообщений и т.д.
- интегрируемость за счет Kafka Connect и собственного протокола на базе TCP, который легко взаимодействует с популярными протоколами передачи данных.
- гарантирует порядок доставки сообщений (FIFO).

Недостатки:
- клиенту нужно заботиться о вычитке сообщений (глупый брокер - умный консьюмер, pull-модель).
- ...

Используется в ситуациях, когда:
- нужно передавать одни и те же данные разным потребителям (вместо нескольких интеграций между системами и их поддержания, мы отливаем в Kafka один раз и даем возможность другим системам делать с ними, что угодно).
- нужно что-либо логгировать, ослеживать и обрабатывать в режиме реального времени (в том числе асинхронно).
- необходимо сохранять порядок чтения сообщений.
- необходимо обрабатывать большое количество данных.


## 2. Основные понятия
Сообщение - базовая единица данных (можно рассматривать как набор байт). Содержит ключ (не всегда) и сообщение. Ключ нужен, если нам нужна гарантия, чтобы сообщения с одним ключом вычитывались одним конкретным консьюмером из группы.

Пакет - группа сообщений (сообщения отправлять по одному невыгодно, поэтому они группируются в пакеты и отправляются пакетами).

Схема - соглашение о структуре сообщений. Обычно avro, так как не зависит от платформы и обеспечивает внутренюю совместимость. Хранятся в реестре схем (schema registry), там поддерживается версионность схем, когда структура сообщения меняется. Позволяет отправлять только сообщения, которые соответствуют схеме из реестра.

Топик - сегментированный append-only журнал, как правило, содержащий сообщения одной предметной области и единой схемы.

Партиция - логическое разделение сообщений в топике. Если не указывать ключ сообщения, то сообщение записывается сначала в 1-ю партицию, потом во 2-ю и т.д. (round-robin), но можно и указать конкретную партицию при записи. Сообщения с одним ключом попадают в одну и ту же партицию. Порядок сообщений внутри партиции сохраняется до тех пор, пока не добавляются новые партиции. Партиции используются для распределения нагрузки между консьюмерами в пределах группы.

Оффсет - смещение сообщения относительно первого полученного в пределах партиции (можно рассматривать как индекс массива сообщений). Нужен для того, что консьюмеры знали, где они остановились читать и с какой позиции им нужно продолжить читать. Обычно хранятся в отдельном топике, но есть вариант сохранять во внешние системы. Главная проблема в атомарности обработки сообщения консьюмером и записи оффсета. Сохранение оффсета: автоматическое - например, раз в 5сек., ручное - консьюмер сам коммитит оффсет (бывает синхронное и асинхронное).

Брокер - нода Kafka, хранящая и обрабатывающая сообщения. Брокеры объединяются в кластер, где один брокер - контроллер. Контроллер нужен, например, для того чтобы назначать ведущие и ведомые реплики партиций при сбоях. Реплики бывают согласованными и рассогласованными (например, если реплика не запрашивала какое-то время оффсет сообщений с ведущей реплики). 

У каждого брокера есть уникальный идентификатор (назначается автоматически или в конфиге - `broker.id`). 
Из основных настроек: 
- `num.partitions`: дефолтное количество партиций в топике.
- `log.dirs`: куда сохраняем сообщения.
- `log.retention.ms`: сколько храним сообщения по времени, по умолчанию 7 дней.
- `log.retention.bytes`: сколько храним сообщения в разделе по байтам.
- `message.max.bytes`: какой максимум байт в сообщении брокер может принять. 

Сообщения удаляются сегментами. Закрытие сегмента определяется параметрами: `log.segment.bytes` и `log.segment.ms`.

## 3. Producer
Продьюсер - сущность для записи сообщений. Общая схема записи сообщений выглядит так: 
- создаем объект, указываем топик, куда хотим отправить, дополнительно можно указать ключ и конкретную партицию.
- сериализуем созданный объект и его ключ (превращаем в байты).
- выбираем партицию, куда будет записано сообщение. Существует специальный объект, который занимается распределением сообщений по партициям (round-robin, если не передаем ключ; встроенный или собственный алгоритм по хешу ключа).
- отправляем сообщение.
- брокер получает сообщение и может отправить или не отправить ответ об успешной записи с метаданными продьюсеру (влияет: `acks` параметр).
- если продьюсер узнает, что сообщение не было записано, то попробует еще раз отправить (влияют: `retries` и `retry.backoff.ms` параметры).

Есть три варианта отправки: отправить и неважно дошло сообщение или нет, отправить и получить синхронно или асинхронно ответ (футура) об успехе.

Основные параметры:
- `batch.size`: максимальный объем памяти в байтах для группировки сообщений в пакеты (пакет может отправить и до достижения значения, когда будет свободный поток).
- `linger.ms`: длительность ожидания доп. сообщений перед отправкой пакета.
- `client.id`: идентификатор клиента, нужен для логгирования продьюсера и выделения квот.
- `compression.type`: алгоритм сжатия сообщений, по дефолту не сжимаются, snappy, lz4, gzip.
- `buffer.memory`: сколько выделяем памяти для буферизации сообщений в памяти.
- `acks`: 0 - пофиг на доставку, отправили и все, 1 - ждем ок от ведущей реплики, all - ждем ок от ведущей и от ведомых реплик.
- `retries`: количество попыток отправки после неудачной записи сообщения.
- `retry.backoff.ms`: сколько ждем перед следующей отправкой после неудачной записи сообщения.
- `max.in.flight.requests.per.connection`: максимальное количество сообщений, которое можно отправить, не дожидаясь ответа от брокера. Если 1, то будет гарантия, что даже в случае повторной отправки порядок сообщений сохранится. Если выставить больше 1 и пытаться несколько раз отправлять сообщение, то можно нарушить порядок.
- `request.timeout.ms`: длительность ожидания ответа от брокера, если ответа нет, то продьюсер попробует еще раз.
- `timeout.ms`: длительность ожидания ответа ведущей реплики ответа от ведомых об успехе записи.
- `max.request.size`: максимальный размер отправляемого сообщения.
