# Краткий экскурс по Kafka

## 1. Что такое и сценарии использования
Apache Kafka - распределенная, масштабируемая, централизованная система обмена сообщениями в режиме реального времени, которая дает возможность публикации потоков данных и подписки на них, их хранения и обработки.

Преимущества:
- горизонтальная масштабируемость путем добавления нод в кластер.
- отказоустойчивость за счет репликации партиций на ведомые ноды.
- безопасность за счет SSL-шифрования, различных вариантов авторизации, гарантий доставки сообщений и т.д.
- интегрируемость за счет Kafka Connect и собственного протокола на базе TCP, который легко взаимодействует с популярными протоколами передачи данных.
- гарантирует порядок доставки сообщений (FIFO).

Недостатки:
- клиенту нужно заботиться о вычитке сообщений (глупый брокер - умный консьюмер, pull-модель).
- ...

Используется в ситуациях, когда:
- нужно передавать одни и те же данные разным потребителям (вместо нескольких интеграций между системами и их поддержания, мы отливаем в Kafka один раз и даем возможность другим системам делать с ними, что угодно).
- нужно что-либо логгировать, ослеживать и обрабатывать в режиме реального времени (в том числе асинхронно).
- необходимо сохранять порядок чтения сообщений.
- необходимо обрабатывать большое количество данных.


## 2. Основные понятия
Сообщение - базовая единица данных (можно рассматривать как набор байт). Содержит ключ (не всегда) и сообщение. Ключ нужен, если нам нужна гарантия, чтобы сообщения с одним ключом вычитывались одним конкретным консьюмером из группы.

Пакет - группа сообщений (сообщения отправлять по одному невыгодно, поэтому они группируются в пакеты и отправляются пакетами).

Схема - соглашение о структуре сообщений. Обычно avro, так как не зависит от платформы и обеспечивает внутренюю совместимость. Хранятся в реестре схем (schema registry), там поддерживается версионность схем, когда структура сообщения меняется. Позволяет отправлять только сообщения, которые соответствуют схеме из реестра.

Топик - сегментированный append-only журнал, как правило, содержащий сообщения одной предметной области и единой схемы.

Партиция - логическое разделение сообщений в топике. Если не указывать ключ сообщения, то сообщение записывается сначала в 1-ю партицию, потом во 2-ю и т.д. (round-robin), но можно и указать конкретную партицию при записи. Сообщения с одним ключом попадают в одну и ту же партицию. Порядок сообщений внутри партиции сохраняется до тех пор, пока не добавляются новые партиции. Партиции используются для распределения нагрузки между консьюмерами в пределах группы.

Оффсет - смещение сообщения относительно первого полученного в пределах партиции (можно рассматривать как индекс массива сообщений). Нужен для того, что консьюмеры знали, где они остановились читать и с какой позиции им нужно продолжить читать. Обычно хранятся в отдельном топике, но есть вариант сохранять во внешние системы. Главная проблема в атомарности обработки сообщения консьюмером и записи оффсета. Сохранение оффсета: автоматическое - например, раз в 5сек., ручное - консьюмер сам коммитит оффсет (бывает синхронное и асинхронное). Можно фиксировать заданное смещение, можно получать заданное смещение.

Брокер - нода Kafka, хранящая и обрабатывающая сообщения. Брокеры объединяются в кластер, где один брокер - контроллер. Контроллер нужен, например, для того чтобы назначать ведущие и ведомые реплики партиций при сбоях. Реплики бывают согласованными и рассогласованными (например, если реплика не запрашивала какое-то время оффсет сообщений с ведущей реплики). 

У каждого брокера есть уникальный идентификатор (назначается автоматически или в конфиге - `broker.id`). 
Из основных настроек: 
- `num.partitions`: дефолтное количество партиций в топике.
- `log.dirs`: куда сохраняем сообщения.
- `log.retention.ms`: сколько храним сообщения по времени, по умолчанию 7 дней.
- `log.retention.bytes`: сколько храним сообщения в разделе по байтам.
- `message.max.bytes`: какой максимум байт в сообщении брокер может принять. 

Сообщения удаляются сегментами. Закрытие сегмента определяется параметрами: `log.segment.bytes` и `log.segment.ms`.

## 3. Producer
Продьюсер - сущность для записи сообщений. Общая схема записи сообщений выглядит так: 
- создаем объект, указываем топик, куда хотим отправить, дополнительно можно указать ключ и конкретную партицию.
- сериализуем созданный объект и его ключ (превращаем в байты).
- выбираем партицию, куда будет записано сообщение. Существует специальный объект, который занимается распределением сообщений по партициям (round-robin, если не передаем ключ; встроенный или собственный алгоритм по хешу ключа).
- отправляем сообщение.
- брокер получает сообщение и может отправить или не отправить ответ об успешной записи с метаданными продьюсеру (влияет: `acks` параметр).
- если продьюсер узнает, что сообщение не было записано, то попробует еще раз отправить (влияют: `retries` и `retry.backoff.ms` параметры).

Есть три варианта отправки: отправить и неважно дошло сообщение или нет, отправить и получить синхронно или асинхронно ответ (футура) об успехе.

Основные параметры:
- `batch.size`: максимальный объем памяти в байтах для группировки сообщений в пакеты (пакет может отправить и до достижения значения, когда будет свободный поток).
- `linger.ms`: длительность ожидания доп. сообщений перед отправкой пакета.
- `client.id`: идентификатор клиента, нужен для логгирования продьюсера и выделения квот.
- `compression.type`: алгоритм сжатия сообщений, по дефолту не сжимаются, snappy, lz4, gzip.
- `buffer.memory`: сколько выделяем памяти для буферизации сообщений в памяти.
- `acks`: 0 - пофиг на доставку, отправили и все, 1 - ждем ок от ведущей реплики, all - ждем ок от ведущей и от ведомых реплик.
- `retries`: количество попыток отправки после неудачной записи сообщения.
- `retry.backoff.ms`: сколько ждем перед следующей отправкой после неудачной записи сообщения.
- `max.in.flight.requests.per.connection`: максимальное количество сообщений, которое можно отправить, не дожидаясь ответа от брокера. Если 1, то будет гарантия, что даже в случае повторной отправки порядок сообщений сохранится. Если выставить больше 1 и пытаться несколько раз отправлять сообщение, то можно нарушить порядок.
- `request.timeout.ms`: длительность ожидания ответа от брокера, если ответа нет, то продьюсер попробует еще раз.
- `timeout.ms`: длительность ожидания ответа ведущей реплики ответа от ведомых об успехе записи.
- `max.request.size`: максимальный размер отправляемого сообщения.

## 4. Consumer
Консьюмер - сущность для чтения сообщений. Могут объединяться в группы. Каждые члены группы читают свои партиции. Если консьюмеров больше, чем партиций, то кто-то будет отдыхать.
Каждый консьюмер регулярно направляет брокеру-координатору сигналы (для разных групп может быть свой), что он жив (например, вместе с вычиткой данных или с сохранением оффсета). Если консьюмер не отправляет сигналы какое-то время, то инициируется ребаланс (передача партиции от одного консьюмера другому). Не факт, что при возврате упавшего консьюмера ему достанется та же партиции для обработке, что было до падения.

Основные параметры:
- `fetch.min.bytes`: минимальный объем сообщений в пакете для получения, если не дотягивает, то ждем пока дотянет.
- `fetch.max.wait.ms`: длительность ожидания доп. сообщений перед получением пакета (дефолт 500мс).
- `max.partition.fetch.bytes`: максимальное число возвращаемых байт в расчете на одну партицию.
- `session.timout.ms`: сколько времени можно без отправки сигналов о жизнеспособности.
- `heartbeat.interval.ms`: частота отправки брокеру-координатору сигналов о жизнеспособности.
- `auto.offset.reset`: если отсуствует зафиксированное смещение, то latest скажет читать самое позднее, а earliest - самое ранее.
- `enable.auto.commit`: включает автоматическую фиксацию смещений.
- `partition.assignment.strategy`: Range, RoundRobin.
- `client.id`: идентификатор клиента, для логгов и квот.
- `max.poll.records`: максимальное количество записей возвращаемое при одном вызове метода poll.

Семантики доставки сообщений:
- `at most once` (не более одного раза). После доставки доставить снова не можем, то есть можем потерять сообщение, если консьюмер не сможет обработать.
- `at least once` (не менее одного раза). Можем обработать два раза одно и то же сообщение, поэтому лучше использовать в сочетании с идемпотентностью.
- `exactly once` (ровно один раз). На практике трудно добиться.
